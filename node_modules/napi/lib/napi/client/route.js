/*!
 * napi
 * Copyright(c) 2012 Gabriele Di Stefano <gabriele.ds@gmail.com>
 * MIT Licensed
 */

var Napi = require('../../napi')
  , _ = require('underscore')
  , request = require('request')
  , path = require('path')
  ;


Napi.define('napi.client.route', {
  
  initialize: function(){
    this.parseMethods();
    this.parseChildren();
  },
  
  // parseChildren
  parseChildren: function(){
    var self = this;
    
    if(self.route.children){
      _.each(self.route.children, function(route, name){
        route.name = name;
        self.__defineGetter__(route.name, function () {
          delete self[route.name];
          return self[route.name] = Napi.create(self.src ? self.name + '.' + route.name : 'napi.client.route', {
            client: self.client || self,
            name: route.name,
            route: route
          })
        })
      })  
    }
  },
  
  // parseMethods
  parseMethods: function(){
    var self = this
      , client = self.client || self
      ;
    
    if(self.route.methods){
      _.each(self.route.methods, function(action, name){
        action.name = name;
        
        if(!action.public && !action.private){
          action.public = action.private = action;
        }
        
        // build
        _.each(['public', 'private'], function(type){
          
          type = action[type];
          
          if(type && !type._built){
            type._built = true;
            
            // defaults
            _.defaults(type, {
              method: 'GET',
              url: '/',
              params: {}
            });
            
            // check params
            _.each(type.params, function(param, name){
              _.defaults(param, client.params[name] || client.params['default']);
            });
            
            // get params from url and make them required
            _.each(type.url.match(/\:(\w+)/g) || [], function(name){
              name = name.replace(/^\:/, '');
              
              if(!type.params[name]){
                type.params[name] = client.params[name] || client.params['default'];
              }
              type.params[name].required = true;
            });
                  
          }
        });
        
        // set the method
        self[action.name] = function(params, callback){
          
          if(_.isFunction(params)){
            callback = params;
            params = {};
          }else{
            params = params || {};
            callback = callback || function(){};
          }
          
          var err = null
            , actionType = client.isAuthenticated ? action.private : action.public;
            ;
          
          // check if function is availabe on types
          if(client.isAuthenticated && !action.private){
            err = 'The method \"' + self.name + '.' + action.name + '\" is not available with the authentication.';
          }else if(!client.isAuthenticated && !action.public){
            err = 'The method \"' + self.name + '.' + action.name + '\" is not available without the authentication.';
          }
          
          // validate given params
          if(!err){
            _.each(actionType.params, function(param, name){    
            
              if(_.isUndefined(params[name])){
                // check required
                if(param.required){
                  err = 'The parameter \"' + name + '\" is required.';
                  return false;
                }
              }else{
                // check type
                if(param.type && (typeof params[name] != param.type)){
                  err = 'The parameter \"' + name + '\" is not a \"' + param.type + '\".';
                  return false;
                }
                // check validation
                if(param.validation && !(new RegExp(param.validation)).test(params[name])){
                  err = 'The parameter \"' + name + '\" does not match \"' + param.validation + '\".';
                  return false
                }
              }
            });
          }
          
          if(err){
            console.log(['\033[31m', '[napi - err]', '\033[39m'].join(''), err);
            return false;
          }
          
          // build the url mergin the params
          actionType.url = actionType.url.replace(/\:(\w+)/g, function(match, param) {
            return !_.isUndefined(params[param]) ? params[param] : match;
          });
          
          var headers = {}
            , qs = {}
            ;
          
          if(client.isAuthenticated){
            headers.authorization = "Basic " + client.auth;
            qs = params;
          }
          
          // make the call
          request({
            method: actionType.method,
            url: client.host + actionType.url,
            headers: headers,
            qs: qs
          }, function(err, res, body){
            if(err){
              console.log(['\033[31m', '[napi - err]', '\033[39m'].join(''), err);  
            }else{
              callback.apply(self, [err, JSON.parse(body)]);  
            }
          });
          
          // return
          if(action['return']){
            console.dir(action)
            return Napi.create(action['return'], action);
          }
        }
      });      
    }

        
  }
  
});

